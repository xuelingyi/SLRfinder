### NOTE: run this script in each datafolder
module load r-env-singularity
srun singularity_wrapper exec Rscript --no-save ../1_getLDcluster.R

************************* 1_getLDcluster.R **********************************
library(igraph)
#https://cloud.r-project.org/web/packages/igraph/igraph.pdf
library(data.table)

## input (LD.data): the VCFtools-estimated edge list (*.geno.ld) of correlation coefficients on SNP pairs.
## output: a white list of SNPs that are in LD (threshold set by min_LD, default 0.9) and clusters of a minimum number of SNPs (min.cl.size, default 10).
## NOTE: run the function on each chr separately (the target region, SDR, should be continuous and one the same sex chromosomes)
get_single_LD_cluster <- function(LD.data, min_LD = 0.85, min.cl.size = 20){

  #Read in the edge list
  geno.LD<-read.table(LD.data, header = T)
  names(geno.LD) = c("CHR", "from", "to", "N_INDV", "r2")
  chr = unique(geno.LD$CHR)
  #Remove edges lower than min_LD
  white.list <- subset(geno.LD, as.numeric(r2) > min_LD)

  #Parse the edge data to create a graph object
  g <- graph_from_edgelist(apply(white.list[,c("from", "to")], 2, function(o) as.character(o)), directed = FALSE)
  #Decompose the graph object into a list of components (i.e., LD clusters) and only keep the components containing at least min.cl.size number of vertices (i.e., SNPs)
  d_g <- decompose(g, min.vertices = min.cl.size)
  #For each component (i.e., LD cluster), create a vertex sequence (vs) containing all graph vertices (i.e., SNPs named by positions on this chr)
  d_g <- lapply(d_g, function(cl) V(cl)$name)

  #Summerize data for each LD cluster
  out <- rbindlist(lapply(d_g, function(dg){
    #number of SNPs (nodes)
    nSNPs <- length(dg)
    #mean LD among SNPs in the LD cluster (edge weight)
    mean_LD <- mean(as.numeric(white.list[white.list$from %in% dg & white.list$to %in% dg, "r2"]))
    #number of SNP pairs having high LD in this cluseter (retained edges)
    nE <- nrow(white.list[white.list$from %in% dg & white.list$to %in% dg, ])
    #retained number of edges/nodes as an approximate of clustering coefficiency (higher c means tighter clustering)
    c <- nE/nSNPs
    data.table(chr, nSNPs, mean_LD, nE, c, SNPs=list(dg))
  }))
  return(out)
}

## run the above function using different parameter combinations
## run this within the dataset folder
for (min_LD in c(0.8, 0.85, 0.9)) {
  for (min.cl.size in c(10, 20)) {

    ## create the paramter data folder and change directory inside
    system(paste0("mkdir ", "LD", min_LD*10, "cl", min.cl.size))
    setwd(paste0("LD", min_LD*10, "cl", min.cl.size))
    system(paste0("mkdir ", "whitelist"))

    ## generate data using the current parameters
    data_cls <- NULL
    for(i in c(1:21)){
      LD.data = paste0("../GenoLD.snp100/v7LG", i, "_a15m75.geno.ld")
      chr=paste0("LG", i)
      #sink("./whitelist/mylog", append=T)
      out = get_single_LD_cluster(LD.data, min_LD = min_LD, min.cl.size=min.cl.size)
      #print(paste0(out$chr, ": ", out$nSNPs))
      #sink()
      position = as.data.frame(unlist(out$SNPs))
      position = cbind(rep(chr, sum(out$nSNPs)), position)
      write.table(position, paste0("./whitelist/position.", chr, ".list"), sep="\t", quote = F, row.names = F)
      data_cls <- rbind(data_cls, out)
    }

    data_cls$SNPs = apply(data_cls, 1, function(cl){ paste0(cl$chr, "_", cl$SNPs)})
    saveRDS(data_cls, file="data_cls.rds")
    setwd("../")
  }
}
********************************************************************
## run VCFTools in unix (can also do this in R system if preferred)
## extract SNPs for each parameter test and each chr
ls | grep cl > subfolders
module load vcftools

while read subfolder
do
cd ${subfolder}
mkdir file012

for chr in {1..21}
do
vcftools --gzvcf ../a15m75/*_v7LG${chr}_a15m75.vcf.gz \
--positions ./whitelist/position.LG${chr}.list \
--012 \
--out ./file012/v7LG${chr}_a15m75_LD${LD}cl${cl}
done

cd ../
done < subfolders

